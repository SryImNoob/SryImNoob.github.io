---
layout: post
title: Effective Java
categories: Tech
description: 
tags: Tech Java
---

# Notes on Effective Java

Contents
  - [x] 1 用静态工厂方法代替构造器
  - [x] 2 遇到多个构造器参数时要考虑使用构建器
  - [x] 3 用私有构造器或者枚举类型强化Singleton属性
  - [x] 4 通过私有构造器强化不可实例化的能力
  - [x] 5 优先考虑依赖注入来引用资源
  - [x] 6 避免创建不必要的对象
  - [x] 7 消除过期点对象引用
  - [x] 8 避免使用终结方法和清除方法
  - [x] 9 try-with-resources 优先于 try-finally
  - [x] 10 覆盖equals时请遵守通用约定
  - [x] 11 覆盖equals时总要覆盖hashCode
  - [x] 12 始终要覆盖toString
  - [x] 13 谨慎地覆盖clone
  - [x] 14 考虑实现Comparable接口
  - [x] 15 使类和成员的可访问性最小化
  - [x] 16 要在公有类而非公有域中使用访问方法
  - [x] 17 使可变性最小化
  - [x] 18 复合优于继承
  - [x] 19 要么设计继承并提供文档说明,要么禁止继承
  - [x] 20 接口优于抽象类
  - [x] 21 为后代设计接口
  - [x] 22 接口只用于定义类型
  - [x] 23 类层次优于标签类
  - [x] 24 静态成员类优于非静态成员类
  - [x] 25 限制源文件为单个顶级类
  - [x] 26 请不要使用原生态类型
  - [x] 27 消除非受检的警告
  - [x] 28 列表优于数组
  - [x] 29 优先考虑泛型
  - [x] 30 优先考虑泛型方法
  - [x] 31 利用有限制通配符来提升API的灵活性
  - [x] 32 谨慎并用泛型和可变参数
  - [x] 33 优先考虑类型安全的异构容器
  - [x] 34 使用枚举类型替代整型常量
  - [x] 35 使用实例属性替代序数
  - [x] 36 使用EnumSet替代位属性
  - [x] 37 使用EnumMap替代序数索引
  - [x] 38 使用接口模拟可扩展的枚举
  - [x] 39 注解优于命名模式
  - [x] 40 始终使用Override注解
  - [x] 41 使用标记接口定义类型
  - [x] 42 lambda表达式优于匿名类
  - [x] 43 方法引用优于lambda表达式
  - [x] 44 优先使用标准的函数式接口
  - [x] 45 明智审慎地使用Stream
  - [x] 46 优先考虑流中无副作用的函数
  - [x] 47 优先使用Collection而不是Stream来作为方法的返回类型
  - [x] 48 谨慎使用流并行
  - [x] 49 检查参数有效性
  - [x] 50 必要时进行防御性拷贝
  - [x] 51 仔细设计方法签名
  - [x] 52 明智审慎地使用重载
  - [x] 53 明智审慎地使用可变参数
  - [x] 54 返回空的数组或集合，不要返回 null
  - [x] 55 明智审慎地返回 Optional
  - [x] 56 为所有已公开的 API 元素编写文档注释
  - [x] 57 最小化局部变量的作用域
  - [x] 58 for-each 循环优于传统 for 循环
  - [x] 59 了解并使用库
  - [x] 60 若需要精确答案就应避免使用 float 和 double 类型
  - [x] 61 基本数据类型优于包装类
  - [x] 62 当使用其他类型更合适时应避免使用字符串
  - [x] 63 当心字符串连接引起的性能问题
  - [x] 64 通过接口引用对象
  - [x] 65 接口优于反射
  - [x] 66 明智审慎地本地方法
  - [x] 67 明智审慎地进行优化
  - [x] 68 遵守被广泛认可的命名约定
  - [x] 69 只针对异常的情况下才使用异常
  - [x] 70 对可恢复的情况使用受检异常，对编程错误使用运行时异常
  - [x] 71 避免不必要的使用受检异常
  - [x] 72 优先使用标准的异常
  - [x] 73 抛出与抽象对应的异常
  - [x] 74 每个方法抛出的异常都需要创建文档
  - [x] 75 在细节消息中包含失败一捕获信息
  - [x] 76 保持失败原子性
  - [x] 77 不要忽略异常
  - [x] 78 同步访问共享的可变数据
  - [x] 79 避免过度同步
  - [x] 80 executor, task 和 stream 优先于线程
  - [x] 81 相比 wait 和 notify 优先使用并发工具
  - [x] 82 文档应包含线程安全属性
  - [x] 83 明智审慎的使用延迟初始化
  - [x] 84 不要依赖线程调度器
  - [x] 85 优先选择 Java 序列化的替代方案
  - [x] 86 非常谨慎地实现 Serializable
  - [x] 87 考虑使用自定义的序列化形式
  - [x] 88 保护性的编写 readObject 方法
  - [x] 89 对于实例控制，枚举类型优于 readResolve
  - [x] 90 考虑用序列化代理代替序列化实例

Notes:
  - Item 45 and Item 47: [Cartesian Product](https://freopen.com/language/2020/08/11/Cartesian-Product.html)
  
