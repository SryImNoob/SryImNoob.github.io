---
layout: mindmap
title: Effective Java
categories: Note
description: 
tags: Tech Java
---

# Effective Java

Contents
  - [x] 1 用静态工厂方法代替构造器
  - [x] 2 遇到多个构造器参数时要考虑使用构建器
  - [x] 3 用私有构造器或者枚举类型强化Singleton属性
  - [x] 4 通过私有构造器强化不可实例化的能力
  - [x] 5 优先考虑依赖注入来引用资源
  - [x] 6 避免创建不必要的对象
  - [x] 7 消除过期点对象引用
  - [x] 8 避免使用终结方法和清除方法
  - [x] 9 try-with-resources 优先于 try-finally
  - [x] 10 覆盖equals时请遵守通用约定
  - [x] 11 覆盖equals时总要覆盖hashCode
  - [x] 12 始终要覆盖toString
  - [x] 13 谨慎地覆盖clone
  - [x] 14 考虑实现Comparable接口
  - [x] 15 使类和成员的可访问性最小化
  - [x] 16 要在公有类而非公有域中使用访问方法
  - [x] 17 使可变性最小化
  - [x] 18 复合优于继承
  - [x] 19 要么设计继承并提供文档说明,要么禁止继承
  - [x] 20 接口优于抽象类
  - [x] 21 为后代设计接口
  - [x] 22 接口只用于定义类型
  - [x] 23 类层次优于标签类
  - [x] 24 静态成员类优于非静态成员类
  - [x] 25 限制源文件为单个顶级类
  - [x] 26 请不要使用原生态类型
  - [x] 27 消除非受检的警告
  - [x] 28 列表优于数组
  - [x] 29 优先考虑泛型
  - [x] 30 优先考虑泛型方法
  - [x] 31 利用有限制通配符来提升API的灵活性
  - [x] 32 谨慎并用泛型和可变参数
  - [x] 33 优先考虑类型安全的异构容器
  


# 一 引言

# 二 创建和销毁对象

## 1 用静态工厂方法代替构造器

## 2 遇到多个构造器参数时要考虑使用构建器

## 3 用私有构造器或者枚举类型强化Singleton属性

## 4 通过私有构造器强化不可实例化的能力

## 5 优先考虑依赖注入来引用资源

## 6 避免创建不必要的对象

## 7 消除过期点对象引用

## 8 避免使用终结方法和清除方法

## 9 try-with-resources 优先于 try-finally

# 三 对于所有对象都通用的方法

## 10 覆盖equals时请遵守通用约定

## 11 覆盖equals时总要覆盖hashCode

## 12 始终要覆盖toString

## 13 谨慎地覆盖clone

## 14 考虑实现Comparable接口

# 四 类和接口

## 15 使类和成员的可访问性最小化

## 16 要在公有类而非公有域中使用访问方法

## 17 使可变性最小化

## 18 复合优于继承

## 19 要么设计继承并提供文档说明,要么禁止继承

## 20 接口优于抽象类

## 21 为后代设计接口

## 22 接口只用于定义类型

## 23 类层次优于标签类

## 24 静态成员类优于非静态成员类

## 25 限制源文件为单个顶级类

# 五 泛型

## 26 请不要使用原生态类型

## 27 消除非受检的警告

## 28 列表优于数组

## 29 优先考虑泛型

## 30 优先考虑泛型方法

## 31 利用有限制通配符来提升API的灵活性

## 32 谨慎并用泛型和可变参数

## 33 优先考虑类型安全的异构容器
  